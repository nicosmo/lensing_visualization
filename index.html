<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Visualizing Gravitational Lensing</title>
    <style>
        /* Global Styles
           Sets up the full-screen immersive black background for space visualization.
        */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: white;
        }

        /* Canvas Container
           Holds the WebGL output. Cursor is set to crosshair to indicate the lens position is interactive.
        */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            cursor: crosshair;
        }

        /* UI Overlay
           Floating control panel on the left side.
           Uses backdrop-filter to blur the space background behind the controls.
        */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(8, 15, 25, 0.9);
            padding: 16px;
            border-radius: 10px;
            border: 1px solid rgba(100, 200, 255, 0.15);
            backdrop-filter: blur(8px);
            width: 260px;
            pointer-events: auto;
            user-select: text;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            transition: height 0.3s ease, padding 0.3s ease;
            overflow: hidden;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Custom scrollbar styling for the UI panel */
        #ui-layer::-webkit-scrollbar {
            width: 4px;
        }
        #ui-layer::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        #ui-layer::-webkit-scrollbar-thumb {
            background: #4facfe;
            border-radius: 2px;
        }

        /* Minimized state for the UI panel */
        #ui-layer.minimized {
            height: 28px;
            padding-bottom: 0;
            overflow: hidden;
        }
        #ui-layer.minimized .control-content {
            opacity: 0;
            pointer-events: none;
        }

        .ui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        h1 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 700;
            color: #b3e5ff;
            letter-spacing: 0.3px;
        }

        #toggle-btn {
            background: transparent;
            border: none;
            color: #4facfe;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            padding: 0 4px;
            transition: transform 0.3s;
        }
        #toggle-btn:hover {
            color: white;
        }

        .control-content {
            transition: opacity 0.2s ease;
            opacity: 1;
        }

        p {
            font-size: 0.75rem;
            color: #8fb8e0;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .credit-text {
            font-size: 0.7rem;
            color: #8fb8e0;
            margin-bottom: 12px;
            font-style: italic;
            opacity: 0.9;
        }

        /* Control Groups for Sliders and Buttons */
        .control-group {
            margin-bottom: 12px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }

        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            margin-bottom: 4px;
            color: #ccc;
            font-weight: 500;
        }

        /* Custom Range Slider Styling */
        input[type="range"] {
            width: 100%;
            cursor: pointer;
            height: 4px;
            background: #334;
            border-radius: 2px;
            appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4facfe;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .grid-options, .model-options {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .preset-btn, .model-btn {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #8fb8e0;
            padding: 6px 0;
            font-size: 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            min-width: 60px;
        }
        .preset-btn:hover, .model-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }
        .preset-btn.active, .model-btn.active {
            background: rgba(79, 172, 254, 0.3);
            border-color: #4facfe;
            color: white;
            font-weight: bold;
        }

        input[type="file"] {
            display: none;
        }
        .file-upload-btn {
            display: block;
            background: rgba(79, 172, 254, 0.15);
            border: 1px dashed rgba(79, 172, 254, 0.5);
            color: #4facfe;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
            transition: background 0.2s, color 0.2s;
            margin-top: 8px;
        }
        .file-upload-btn:hover {
            background: rgba(79, 172, 254, 0.3);
            color: white;
        }

        .layer-list {
            margin-top: 4px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .layer-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            padding: 4px 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .layer-name {
            font-size: 0.7rem;
            color: #7affb5;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 170px;
        }

        .remove-layer-btn {
            background: none;
            border: none;
            color: #ff5555;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            padding: 0 0 0 8px;
            line-height: 1;
            transition: color 0.2s;
        }
        .remove-layer-btn:hover {
            color: #ffaaaa;
        }

        .reset-container {
            margin-top: 16px;
            text-align: center;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .reshuffle-btn {
            background: rgba(79, 172, 254, 0.15);
            border: 1px solid rgba(79, 172, 254, 0.4);
            color: #4facfe;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .reshuffle-btn:hover {
            background: rgba(79, 172, 254, 0.3);
            color: white;
        }
        .reset-main-btn {
            background: rgba(255, 85, 85, 0.15);
            border: 1px solid rgba(255, 85, 85, 0.3);
            color: #ff8888;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .reset-main-btn:hover {
            background: rgba(255, 85, 85, 0.3);
            color: white;
        }

        .value-display {
            color: #7affb5;
            font-weight: bold;
            font-family: monospace;
        }

        /* HUD Instructions
           "Drag to move" text at the bottom.
        */
        .instructions {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: opacity 0.5s;
        }

        /* Lock Indicator
           Appears when user clicks to lock the lens position.
        */
        #lock-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            color: #ff5555;
            font-weight: bold;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid rgba(255, 85, 85, 0.4);
            display: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 100;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 1.2rem;
            font-weight: 300;
            letter-spacing: 1px;
            text-align: center;
            width: 100%;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading">Generating Galaxy Field...</div>
    <div id="canvas-container"></div>
    <div id="lock-indicator">LOCKED</div>

    <div id="ui-layer">
        <div class="ui-header">
            <h1>Lensing Visualization </h1>
            <button id="toggle-btn" title="Toggle Settings">–</button>
        </div>

        <div class="control-content">
            <p>Interactive visualization of a massive cluster or a cosmic void bending light from background layers. A qualitative representation of lensing effects.</p>
            <p id="credit-text" class="credit-text">Concept & Visualization by Nico Schuster and Andres Salcedo</p>
            <p class="credit-text" style="margin-top: -8px;">
            <a href="https://github.com/nicosmo/lensing_visualization/" target="_blank" style="color: #4facfe; text-decoration: none;">View and more info on GitHub</a>
            </p>

            <div class="control-group">
                <label>Physics Model</label>
                <div class="model-options">
                    <button class="model-btn active" id="btn-model-point" data-model="0">Point Mass</button>
                    <button class="model-btn" id="btn-model-nfw" data-model="1">NFW Halo</button>
                    <button class="model-btn" id="btn-model-void" data-model="2">Voids</button>
                </div>
            </div>

            <div class="control-group">
                <label>Background Source</label>
                <div style="display: flex; flex-direction: column; gap: 4px; margin-bottom: 8px;">
                    <div style="display: flex; gap: 4px;">
                        <button class="preset-btn active" id="btn-galaxies" data-type="galaxies" style="flex:1">Galaxies</button>
                        <button class="preset-btn" id="btn-bw" data-type="bw-grid" style="flex:1">B&W Line Grid</button>
                    </div>
                    <div style="display: flex; gap: 4px;">
                        <button class="preset-btn" id="btn-col" data-type="color-grid" style="flex:1">Color Line Grid</button>
                        <button class="preset-btn" id="btn-dotted" data-type="dotted-grid" style="flex:1">Color Dotted Grid</button>
                    </div>
                </div>

                <div id="layer-list" class="layer-list"></div>

                <label for="bg-upload" id="upload-label" class="file-upload-btn">Add Own Background Image</label>
                <input type="file" id="bg-upload" accept="image/*">
            </div>

            <div class="control-group">
                <label id="mass-label">
                    Cluster Mass
                    <span id="mass-val" class="value-display">100%</span>
                </label>
                <input type="range" id="mass-slider" min="0" max="200" value="100">
            </div>

            <div class="control-group">
                <label id="spread-label">
                    Cluster Spread
                    <span id="spread-val" class="value-display">1.00x</span>
                </label>
                <input type="range" id="spread-slider" min="0" max="200" value="100">
            </div>

            <div class="control-group">
                <label>
                    Number Of Background Layers
                    <span id="layers-val" class="value-display">3</span>
                </label>
                <input type="range" id="layers-slider" min="1" max="8" step="1" value="3">
            </div>

            <div class="control-group">
                <label>
                    <span id="density-label-text">Galaxy Density</span>
                    <span id="density-val" class="value-display">100%</span>
                </label>
                <input type="range" id="density-slider" min="0" max="200" value="100">
            </div>

            <div class="control-group">
                <label>
                    Galaxy Brightness
                    <span id="bright-val" class="value-display">100%</span>
                </label>
                <input type="range" id="bright-slider" min="0" max="200" value="100">
            </div>

            <div class="control-group">
                <label id="core-label">
                    Show Dark Matter Halo
                    <input type="checkbox" id="core-check" checked>
                </label>
            </div>

            <div class="reset-container">
                <button id="reshuffle-btn" class="reshuffle-btn">Reshuffle Galaxies</button>
                <button id="snapshot-btn" class="reshuffle-btn">Save Snapshot</button>
                <button id="reset-main" class="reset-main-btn">Reset All Settings</button>
            </div>
        </div>
    </div>

    <div class="instructions" id="instruct">Drag to move • Click to Lock</div>

    <script>
        // --- 0. Seeded Random Number Generator ---
        // A seeded RNG is used so that the "Reshuffle" feature generates a consistent
        // galaxy field for a specific seed, allowing for reproducible visuals during a session.
        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        let masterSeed = Math.floor(Math.random() * 100000);

        // --- 1. Procedural Generation Functions ---

        // Draws a single 2D galaxy onto a canvas context.
        // It uses radial gradients for the core/disk and bezier curves to draw spiral arms
        // if the galaxy type is spiral. This is called hundreds of times to populate textures.
        function drawGalaxyClassic(ctx, boundsSize, typeConfig, rng = Math.random) {
            const r = rng;
            const x = r() * boundsSize;
            const y = r() * boundsSize;

            // Determine if spiral or elliptical
            let isSpiral = r() > 0.5;
            if (typeConfig.isCluster) isSpiral = false;

            // Randomize color properties (Hue, Saturation, Lightness)
            let hue, sat, light;
            if (isSpiral) {
                hue = 190 + r() * 60; // Blue/Cyan range
                sat = 50 + r() * 40;
                light = 75 + r() * 20;
            } else {
                hue = 25 + r() * 40;  // Orange/Yellow range
                sat = 60 + r() * 40;
                light = 70 + r() * 20;
            }

            let size = typeConfig.minSize + r() * (typeConfig.maxSize - typeConfig.minSize);

            // Occasional large outlier galaxy
            if (!typeConfig.isForeground && !typeConfig.isCluster && r() > 0.98) size *= 2.0;

            let aspect;
            if (!typeConfig.isForeground && !typeConfig.isCluster) {
                aspect = 0.6 + r() * 0.3;
            } else {
                aspect = 0.4 + r() * 0.6;
            }

            const angle = r() * Math.PI * 2;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.scale(1, aspect);

            // Draw Core
            const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
            coreGrad.addColorStop(0, `hsla(${hue}, ${sat}%, 95%, 1.0)`);
            coreGrad.addColorStop(0.5, `hsla(${hue}, ${sat}%, ${light}%, 0.8)`);
            coreGrad.addColorStop(1, `hsla(${hue}, ${sat}%, ${light}%, 0.0)`);
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Draw Disk
            const diskGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            diskGrad.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, 0.4)`);
            diskGrad.addColorStop(0.6, `hsla(${hue}, ${sat}%, ${light}%, 0.1)`);
            diskGrad.addColorStop(1, "transparent");
            ctx.fillStyle = diskGrad;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();

            // Draw Spiral Arms (if applicable)
            if (isSpiral && size > 4) {
                ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light+10}%, 0.5)`;
                ctx.lineWidth = size * 0.15;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-size * 0.2, 0);
                ctx.bezierCurveTo(-size * 0.5, -size * 1.2, size * 0.8, -size * 1.0, size * 1.2, 0);
                ctx.moveTo(size * 0.2, 0);
                ctx.bezierCurveTo(size * 0.5, size * 1.2, -size * 0.8, size * 1.0, -size * 1.2, 0);
                ctx.stroke();
            }
            ctx.restore();
        }

        // Factory to pre-render sprite sheets for galaxies.
        // Instead of drawing complex vector shapes every frame, we draw them once to a small canvas
        // and reuse that image as a sprite.
        const GalaxyFactory = {
            sprites: { blueSpiral: [], redSpiral: [] },
            generateSprite: function(type, size = 256) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const cx = size / 2;
                const cy = size / 2;

                let hue, sat;
                if (type === 'blueSpiral') {
                    hue = 200 + Math.random() * 40;
                    sat = 60 + Math.random() * 20;
                } else {
                    hue = 10 + Math.random() * 40;
                    sat = 60 + Math.random() * 20;
                }

                // Core
                const coreSize = size * 0.15;
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreSize * 2);
                grad.addColorStop(0, `hsla(${hue}, ${sat}%, 95%, 1)`);
                grad.addColorStop(0.5, `hsla(${hue}, ${sat}%, 60%, 0.5)`);
                grad.addColorStop(1, "transparent");
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(cx, cy, coreSize * 2, 0, Math.PI * 2);
                ctx.fill();

                // Particle Arms
                const armCount = Math.random() > 0.7 ? 3 : 2;
                const winding = 2 + Math.random() * 2;
                const particleCount = 1200;

                for (let i = 0; i < particleCount; i++) {
                    const t = Math.random();
                    const rNorm = Math.pow(t, 1.5);
                    const r = rNorm * (size * 0.45);
                    const angleBase = rNorm * Math.PI * winding;
                    const armOffset = (Math.floor(Math.random() * armCount) / armCount) * Math.PI * 2;
                    const scatter = (Math.random() - 0.5) * (size * 0.15) * rNorm;
                    const theta = angleBase + armOffset;

                    const x = cx + Math.cos(theta) * r + Math.cos(theta + Math.PI/2) * scatter;
                    const y = cy + Math.sin(theta) * r + Math.sin(theta + Math.PI/2) * scatter;

                    const isDust = Math.random() > 0.85;
                    if (isDust) {
                        ctx.fillStyle = `rgba(0,0,0,0.6)`;
                        ctx.beginPath();
                        ctx.arc(x, y, Math.random() * 3 + 1, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        const starHue = hue + (Math.random() * 20 - 10);
                        const starLight = 90 - (rNorm * 40);
                        const alpha = 0.8 - (rNorm * 0.5);
                        ctx.fillStyle = `hsla(${starHue}, ${sat}%, ${starLight}%, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(x, y, Math.random() * 1.5 + 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                return canvas;
            },
            init: function() {
                for(let i=0; i<6; i++) this.sprites.blueSpiral.push(this.generateSprite('blueSpiral'));
                for(let i=0; i<4; i++) this.sprites.redSpiral.push(this.generateSprite('redSpiral'));
            },
            getRandomSprite: function(type, rng) {
                const r = rng ? rng() : Math.random();
                return this.sprites[type][Math.floor(r * this.sprites[type].length)];
            }
        };

        function drawForegroundSprite(ctx, boundsSize, typeConfig, rng = Math.random) {
            const r = rng;
            const x = r() * boundsSize;
            const y = r() * boundsSize;
            const type = r() > 0.5 ? 'blueSpiral' : 'redSpiral';
            const sprite = GalaxyFactory.getRandomSprite(type, r);

            let size = typeConfig.minSize + r() * (typeConfig.maxSize - typeConfig.minSize);
            const rotation = r() * Math.PI * 2;
            const tilt = 0.4 + r() * 0.6;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.scale(1, tilt);
            ctx.drawImage(sprite, -size/2, -size/2, size, size);
            ctx.restore();
        }

        // --- 2. Texture Generation (PRESETS) ---
        // These functions generate the static textures used by the shader.

        // Generates the deep field background of galaxies.
        function createBackgroundTexture(density) {
            const size = 2048;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const rng = mulberry32(masterSeed + 1);

            // Dark background
            ctx.fillStyle = "#010102";
            ctx.fillRect(0, 0, size, size);

            // Add diffuse background nebulosity
            for (let i = 0; i < 60; i++) {
                const x = rng() * size;
                const y = rng() * size;
                const r = rng() * 300 + 100;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                grad.addColorStop(0, `hsla(220, 40%, 15%, 0.05)`);
                grad.addColorStop(1, "transparent");
                ctx.fillStyle = grad;
                ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';

            // Draw galaxies
            const baseCount = 733;
            const count = Math.floor(baseCount * density);

            for (let i = 0; i < count; i++) {
                drawGalaxyClassic(ctx, size, { isForeground: false, isCluster: false, minSize: 2.0, maxSize: 10.0 }, rng);
            }
            return new THREE.CanvasTexture(canvas);
        }

        // Generates a simple Black and White Grid for testing lensing distortions.
        function createBWGridTexture() {
            const size = 2048;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, size, size);

            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ffffff";

            const gridSize = 128;
            const steps = size / gridSize;

            ctx.beginPath();
            for(let i=0; i<=steps; i++) {
                const p = i * gridSize;
                ctx.moveTo(p, 0); ctx.lineTo(p, size);
                ctx.moveTo(0, p); ctx.lineTo(size, p);
            }
            ctx.stroke();

            return new THREE.CanvasTexture(canvas);
        }

        // Generates a colored grid where vertical/horizontal lines have different colors, as well as different colors for each layer.
        function createColorGridTexture() {
            const size = 2048;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, size, size);

            const gridSize = 128;
            const steps = size / gridSize;

            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ff00ff";
            ctx.beginPath();
            for(let i=0; i<=steps; i++) {
                const p = i * gridSize;
                ctx.moveTo(p, 0); ctx.lineTo(p, size);
            }
            ctx.stroke();

            ctx.strokeStyle = "#00ffff";
            ctx.beginPath();
            for(let i=0; i<=steps; i++) {
                const p = i * gridSize;
                ctx.moveTo(0, p); ctx.lineTo(size, p);
            }
            ctx.stroke();

            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(size/2, size/2, 8, 0, Math.PI*2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        // Generates a grid of white dots on a black background.
        // Density determines the spacing between the dots.
        function createDottedGridTexture(density) {
            const size = 2048;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, size, size);

            // Higher density means smaller spacing
            // Base spacing at density 1.0 is 64 pixels
            const safeDensity = Math.max(density, 0.1);
            const idealSpacing = 64 / safeDensity;
            const steps = Math.round(size / idealSpacing);
            const spacing = size / steps; // Ensures perfect wrapping

            for(let x=0; x<=size; x+=spacing) {
                // Rainbow from left to right (Hue based on X coordinate)
                const hue = (x / size) * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;

                for(let y=0; y<=size; y+=spacing) {
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            return new THREE.CanvasTexture(canvas);
        }

        // Generates the "Lens" object itself - the cluster of galaxies in the foreground
        // that acts as the gravitational lens.
        function createClusterTexture(density) {
            const size = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const rng = mulberry32(masterSeed + 2);

            ctx.clearRect(0,0,size,size);

            const baseCount = 25;
            const count = Math.floor(baseCount * density);

            for(let i=0; i<count; i++) {
                // Concentrate galaxies towards the center to simulate a cluster
                const rPower = Math.pow(rng(), 1.6);
                const r = rPower * (size * 0.45);
                const theta = rng() * Math.PI * 2;
                const x = size/2 + r * Math.cos(theta);
                const y = size/2 + r * Math.sin(theta);

                let isSpiral = rng() > 0.5;
                let sizeConfig = { isForeground: false, isCluster: true, minSize: 30, maxSize: 90 };

                if (isSpiral) {
                    ctx.globalCompositeOperation = 'source-over';
                    const type = rng() > 0.5 ? 'blueSpiral' : 'redSpiral';
                    const sprite = GalaxyFactory.getRandomSprite(type, rng);
                    let s = sizeConfig.minSize + rng() * (sizeConfig.maxSize - sizeConfig.minSize);
                    const rot = rng() * Math.PI * 2;
                    const tilt = 0.5 + rng() * 0.5;

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rot);
                    ctx.scale(1, tilt);
                    ctx.drawImage(sprite, -s/2, -s/2, s, s);
                    ctx.restore();
                } else {
                    ctx.globalCompositeOperation = 'screen';
                    ctx.save();
                    ctx.translate(x, y);

                    let hue = 25 + rng() * 40;
                    let sat = 60 + rng() * 40;
                    let light = 70 + rng() * 20;
                    let s = sizeConfig.minSize + rng() * (sizeConfig.maxSize - sizeConfig.minSize);
                    let aspect = 0.4 + rng() * 0.6;
                    let angle = rng() * Math.PI * 2;

                    ctx.rotate(angle);
                    ctx.scale(1, aspect);

                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, s * 0.4);
                    coreGrad.addColorStop(0, `hsla(${hue}, ${sat}%, 95%, 1.0)`);
                    coreGrad.addColorStop(0.5, `hsla(${hue}, ${sat}%, ${light}%, 0.8)`);
                    coreGrad.addColorStop(1, `hsla(${hue}, ${sat}%, ${light}%, 0.0)`);
                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.4, 0, Math.PI * 2);
                    ctx.fill();

                    const diskGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, s);
                    diskGrad.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, 0.4)`);
                    diskGrad.addColorStop(0.6, `hsla(${hue}, ${sat}%, ${light}%, 0.1)`);
                    diskGrad.addColorStop(1, "transparent");
                    ctx.fillStyle = diskGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, s, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            }
            return new THREE.CanvasTexture(canvas);
        }

        // Generates foreground noise/objects that are NOT part of the lens or the background,
        // used to add depth parallax.
        function createForegroundTexture(density) {
            const size = 2048;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const rng = mulberry32(masterSeed + 3);

            ctx.clearRect(0,0,size,size);

            ctx.globalCompositeOperation = 'source-over';

            const baseCount = 40;
            const count = Math.floor(baseCount * density);

            for(let i=0; i<count; i++) {
                drawForegroundSprite(ctx, size, { isForeground: true, isCluster: false, minSize: 25, maxSize: 90 }, rng);
            }
            return new THREE.CanvasTexture(canvas);
        }


        // --- 3. Main Application ---
        let scene, camera, renderer, material, mesh;
        let mouse = new THREE.Vector2(0.5, 0.5);
        let targetMouse = new THREE.Vector2(0.5, 0.5);
        let isLocked = false;

        let currentMode = 'galaxies';
        let manualLayers = [];

        // Application State
        let defaultConfig = {
            mass: 1.0,
            spread: 1.0,
            layers: 3,
            density: 1.0,
            brightness: 1.0,
            showCore: 1.0,
            model: 0
        };

        let config = { ...defaultConfig };

        function init() {
            GalaxyFactory.init();

            randomizeCredits();

            const container = document.getElementById('canvas-container');

            // Setup Orthographic Camera for 2D Shader Pass
            const frustumSize = 2.5;
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(
                -frustumSize / 2, frustumSize / 2,
                frustumSize / 2, -frustumSize / 2,
                0, 1
            );

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Create Textures
            const bgTex = createBackgroundTexture(config.density);
            bgTex.wrapS = THREE.RepeatWrapping;
            bgTex.wrapT = THREE.RepeatWrapping;

            const clusterTex = createClusterTexture(config.density);
            clusterTex.wrapS = THREE.ClampToEdgeWrapping;
            clusterTex.wrapT = THREE.ClampToEdgeWrapping;

            const fgTex = createForegroundTexture(config.density);
            fgTex.wrapS = THREE.RepeatWrapping;
            fgTex.wrapT = THREE.RepeatWrapping;

            document.getElementById('loading').style.display = 'none';

            // Prepare uniforms for manual user uploads (up to 8 layers)
            const manualUniforms = {};
            for(let i=0; i<8; i++) {
                manualUniforms[`u_manual_tex_${i}`] = { value: null };
            }

            // Uniforms pass data from CPU to GPU (Shaders)
            const uniforms = {
                u_bg: { value: bgTex },
                ...manualUniforms,
                u_cluster: { value: clusterTex },
                u_fg: { value: fgTex },
                u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                u_mouse: { value: new THREE.Vector2(0.5, 0.5) },
                u_mass: { value: config.mass },
                u_spread: { value: config.spread },
                u_layers: { value: config.layers },
                u_brightness: { value: config.brightness },
                u_show_core: { value: config.showCore },
                u_model: { value: config.model },
                u_grid_mode: { value: 0.0 },
                u_use_manual: { value: 0.0 },
                u_time: { value: 0 }
            };

            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `;

            /* Fragment Shader
               This is where the physics and rendering logic lives.
            */
            const fragmentShader = `
                uniform sampler2D u_bg;
                uniform sampler2D u_manual_tex_0;
                uniform sampler2D u_manual_tex_1;
                uniform sampler2D u_manual_tex_2;
                uniform sampler2D u_manual_tex_3;
                uniform sampler2D u_manual_tex_4;
                uniform sampler2D u_manual_tex_5;
                uniform sampler2D u_manual_tex_6;
                uniform sampler2D u_manual_tex_7;

                uniform sampler2D u_cluster;
                uniform sampler2D u_fg;
                uniform vec2 u_resolution;
                uniform vec2 u_mouse;
                uniform float u_mass;
                uniform float u_spread;
                uniform float u_layers;
                uniform float u_brightness;
                uniform float u_show_core;
                uniform float u_model;
                uniform float u_grid_mode;
                uniform float u_use_manual;

                varying vec2 vUv;

                // Calculates the NFW (Navarro-Frenk-White) mass profile
                // This describes how density falls off in a dark matter halo.
                float nfw_enclosed(float x) {
                    float val;
                    if (x < 1.0) {
                        float num = log(x/2.0) + log(1.0/x + sqrt(1.0/(x*x) - 1.0)) / sqrt(1.0 - x*x);
                        val = num;
                    } else if (x > 1.0) {
                        float num = log(x/2.0) + acos(1.0/x) / sqrt(x*x - 1.0);
                        val = num;
                    } else {
                        val = 1.0;
                    }
                    return val / x;
                }

                // Calculates deflection for the Void model based on the density profile described.
                // r: distance from center
                // rv: void radius
                // d_in: inner density contrast (rho_in - 1)
                float void_deflection(float r, float rv, float d_in) {
                    float x = r / rv;

                    // --- Fixed Model Parameters ---
                    float d_wall = 0.05;
                    float x_core = 0.1;
                    float lensing_strength = 3.0;
                    // ------------------------------

                    // Pre-calculate constants for the profile
                    // k is the steepness of the quadratic rise from x_core to 1.0
                    float k = (d_wall - d_in) / 0.81; // 0.81 is 0.9^2

                    // 1. CONSTANT CORE (x < 0.1)
                    if (x < x_core) {
                        // Integral of constant d_in * u is 0.5 * d_in * x^2
                        // Deflection = strength * Integral / x
                        return lensing_strength * 0.5 * d_in * x;
                    }

                    // 2. QUADRATIC RISE (0.1 <= x < 1.0)
                    else if (x < 1.0) {
                        // A. Mass of the core
                        float M_core = 0.5 * d_in * x_core * x_core;

                        // B. Mass of the rising part from x_core to x
                        float M_base = 0.5 * d_in * (x * x - x_core * x_core);

                        float v = x - x_core;
                        float M_rise = k * ( (v*v*v*v)*0.25 + x_core * (v*v*v)*(1.0/3.0) );

                        return lensing_strength * (M_core + M_base + M_rise) / x;
                    }

                    // 3. LINEAR RIDGE DROP (1.0 <= x < 1.05)
                    else if (x < 1.05) {
                        // A. Mass of core + rise (fully integrated up to 1.0)
                        float M_core = 0.5 * d_in * x_core * x_core;
                        float M_base = 0.5 * d_in * (1.0 - x_core * x_core);
                        float v_full = 1.0 - x_core;
                        float M_rise = k * ( (v_full*v_full*v_full*v_full)*0.25 + x_core * (v_full*v_full*v_full)*(1.0/3.0) );
                        float M_inner_total = M_core + M_base + M_rise;

                        // B. Mass of the ridge shell
                        // Profile: delta(u) = 1.05 - u
                        // (Note: at u=1.0, delta is 0.05, which matches d_wall )
                        float val_at_x = 0.525 * x * x - (x * x * x) / 3.0;
                        float val_at_1 = 0.525 - 1.0 / 3.0;
                        float M_ridge = val_at_x - val_at_1;

                        return lensing_strength * (M_inner_total + M_ridge) / x;
                    }

                    // 4. OUTSIDE (x >= 1.05)
                    else {
                        // Calculate Total Mass of the void structure
                        // 1. Inner total
                        float M_core = 0.5 * d_in * x_core * x_core;
                        float M_base = 0.5 * d_in * (1.0 - x_core * x_core);
                        float v_full = 0.9;
                        float M_rise = k * ( (v_full*v_full*v_full*v_full)*0.25 + x_core * (v_full*v_full*v_full)*(1.0/3.0) );
                        float M_inner_total = M_core + M_base + M_rise;

                        // 2. Ridge total (Integrated fully to 1.05)
                        float val_at_end = 0.525 * 1.05 * 1.05 - (1.05 * 1.05 * 1.05) / 3.0;
                        float val_at_1   = 0.525 - 1.0 / 3.0;
                        float M_ridge_total = val_at_end - val_at_1;

                        return lensing_strength * (M_inner_total + M_ridge_total) / x;
                    }
                }

                vec3 palette(float t) {
                    vec3 a = vec3(0.5, 0.5, 0.5);
                    vec3 b = vec3(0.5, 0.5, 0.5);
                    vec3 c = vec3(1.0, 1.0, 1.0);
                    vec3 d = vec3(0.00, 0.33, 0.67);
                    return a + b * cos(6.28318 * (c * t + d));
                }

                // Helper to fetch textures from the manual array
                vec4 getManualSample(int index, vec2 uv) {
                    if (index == 0) return texture2D(u_manual_tex_0, uv);
                    if (index == 1) return texture2D(u_manual_tex_1, uv);
                    if (index == 2) return texture2D(u_manual_tex_2, uv);
                    if (index == 3) return texture2D(u_manual_tex_3, uv);
                    if (index == 4) return texture2D(u_manual_tex_4, uv);
                    if (index == 5) return texture2D(u_manual_tex_5, uv);
                    if (index == 6) return texture2D(u_manual_tex_6, uv);
                    if (index == 7) return texture2D(u_manual_tex_7, uv);
                    return vec4(0.0);
                }

                void main() {
                    float aspect = u_resolution.x / u_resolution.y;
                    vec2 uv = vUv;

                    vec2 lensPos = u_mouse;
                    vec2 distVec = (uv - lensPos);
                    distVec.x *= aspect;
                    float r = length(distVec);

                    float baseStrength = u_mass * 0.03;

                    vec3 finalColor = vec3(0.0);

                    // Multi-Plane Lensing Loop:
                    // We simulate depth by iterating through 'layers'.
                    // Layers further back are deflected more than layers close to the lens.
                    for (float i = 0.0; i < 8.0; i++) {
                        if (i >= u_layers) break;

                        float decay = 1.0 / (1.0 + i * 0.4);
                        float layerBrightness = u_brightness * decay;

                        float depth = 1.0 - (i * 0.12);

                        vec2 deflection;

                        // Calculate deflection angle based on chosen model
                        if (u_model < 0.5) {
                            // Point Mass (1/r)
                            float lensStrength = baseStrength * depth;
                            deflection = normalize(distVec) * lensStrength / (r + 0.005);
                        } else if (u_model < 1.5) {
                            // NFW Halo
                            float nfwStrength = baseStrength * depth * 6.0;
                            float rs = max(u_spread * 0.24, 0.01);
                            float x = r / rs;
                            float alpha = nfw_enclosed(x);
                            deflection = normalize(distVec) * nfwStrength * alpha;
                        } else {
                            // Void Model
                            float rv = max(u_spread * 0.24, 0.01);
                            // u_mass is passed as raw slider value scaled 0-2 (0-200%).
                            // We interpret u_mass as the inner density ratio here.
                            float d_in = u_mass - 1.0;
                            float alpha = void_deflection(r, rv, d_in);
                            // Visual scaling to match user request for "slightly stronger" effect
                            float voidStrength = 0.15 * depth;
                            deflection = normalize(distVec) * voidStrength * alpha;
                        }

                        // Apply Parallax and Lensing Deflection
                        float scale = 1.0 + i * 0.12;
                        vec2 layerUv = (uv * scale * vec2(aspect, 1.0)) + vec2(i * 0.3, i * 0.7) - deflection;

                        vec3 texColor;

                        if (u_use_manual > 0.5) {
                            texColor = getManualSample(int(i), layerUv).rgb;
                        } else {
                            texColor = texture2D(u_bg, layerUv).rgb;
                        }

                        // Debug Grid Coloring
                        if (u_grid_mode > 0.5 && u_use_manual < 0.5) {
                            vec3 colVert = palette(i * 0.15);
                            vec3 colHoriz = palette(i * 0.15 + 0.5);
                            vec3 mappedColor = texColor.r * colVert + texColor.g * colHoriz;
                            if (texColor.r > 0.5 && texColor.g > 0.5) mappedColor = vec3(1.0);
                            texColor = mappedColor;
                        }

                        finalColor += texColor * layerBrightness;
                    }

                    // Render the Dark Matter Halo Glow (if enabled)
                    if (u_show_core > 0.5) {
                        if (u_model < 1.5) {
                            // Standard Cluster Halo
                            float haloSize = (u_model > 0.5) ? max(u_spread * 0.2, 0.05) : u_mass * 0.1;
                            float halo = smoothstep(haloSize, 0.0, r);
                            vec3 haloColor = vec3(0.1, 0.12, 0.2) + vec3(0.4, 0.35, 0.3) * halo;
                            finalColor += halo * haloColor * 0.3;
                        } else {
                            // Void Boundary & Center Markers
                            float rv = max(u_spread * 0.24, 0.01);

                            // 1. Dotted Outline at Boundary (rv)
                            float distFromBound = abs(r - rv);
                            float outline = smoothstep(0.003, 0.0, distFromBound);
                            float angle = atan(distVec.y, distVec.x);
                            float dashes = step(0.0, sin(angle * 40.0));
                            vec3 outlineColor = vec3(0.7); // Bright Grey
                            finalColor = mix(finalColor, outlineColor, outline * dashes * 0.8);

                            // 2. X Cross at Center
                            // Rotate coordinates by 45 degrees
                            float s = 0.7071;
                            vec2 local = distVec;
                            vec2 rot = vec2(local.x * s - local.y * s, local.x * s + local.y * s);
                            float thickness = 0.0015;
                            float size = 0.0075;
                            float cross = 0.0;

                            if (abs(rot.x) < thickness && abs(rot.y) < size) cross = 1.0;
                            if (abs(rot.y) < thickness && abs(rot.x) < size) cross = 1.0;

                            finalColor = mix(finalColor, outlineColor, cross);
                        }
                    }

                    // Render the Foreground Cluster (The Lens Object)
                    // Only visible if NOT in Void mode
                    if (u_model < 1.5) {
                        vec2 memberUvCenter = uv - u_mouse;
                        memberUvCenter.x *= aspect;
                        vec2 memberUv = memberUvCenter / (u_spread * 0.24) + 0.5;

                        if(memberUv.x > 0.0 && memberUv.x < 1.0 && memberUv.y > 0.0 && memberUv.y < 1.0) {
                            vec4 clusterSample = texture2D(u_cluster, memberUv);
                            vec3 clusterRgb = clusterSample.rgb * u_brightness;
                            finalColor = mix(finalColor, clusterRgb, clusterSample.a);
                        }
                    }

                    // Render very close foreground stars (No lensing applied to them)
                    vec4 fgSample = texture2D(u_fg, uv);
                    vec3 fgRgb = fgSample.rgb * u_brightness;
                    finalColor = mix(finalColor, fgRgb, fgSample.a);

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            });

            mesh = new THREE.Mesh(new THREE.PlaneGeometry(frustumSize, frustumSize), material);
            scene.add(mesh);

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('click', toggleLock, false);

            animate();
        }

        // --- Event Handlers & Helpers ---

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(e) {
            if (!isLocked) {
                // Normalize mouse to 0..1 range
                targetMouse.x = e.clientX / window.innerWidth;
                targetMouse.y = 1.0 - (e.clientY / window.innerHeight);
            }
        }

        function onTouchMove(e) {
            if(e.touches.length > 0) {
                e.preventDefault();
                if (!isLocked) {
                    targetMouse.x = e.touches[0].clientX / window.innerWidth;
                    targetMouse.y = 1.0 - (e.touches[0].clientY / window.innerHeight);
                }
            }
        }

        function toggleLock(e) {
            isLocked = !isLocked;
            const ind = document.getElementById('lock-indicator');
            const instruct = document.getElementById('instruct');
            const container = document.getElementById('canvas-container');

            if (isLocked) {
                ind.style.display = 'block';
                instruct.innerText = "Click to Unlock";
                container.style.cursor = 'default';
            } else {
                ind.style.display = 'none';
                instruct.innerText = "Drag to move • Click to Lock";
                container.style.cursor = 'crosshair';
                targetMouse.x = e.clientX / window.innerWidth;
                targetMouse.y = 1.0 - (e.clientY / window.innerHeight);
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);

            // Smooth mouse movement
            mouse.x += (targetMouse.x - mouse.x) * 0.1;
            mouse.y += (targetMouse.y - mouse.y) * 0.1;

            // Update Uniforms
            material.uniforms.u_mouse.value.copy(mouse);
            material.uniforms.u_time.value = time * 0.001;
            material.uniforms.u_mass.value = config.mass;
            material.uniforms.u_spread.value = config.spread;

            // Handle switching between manual upload layers and procedural layers
            if (manualLayers.length > 1) {
                material.uniforms.u_layers.value = manualLayers.length;
                material.uniforms.u_use_manual.value = 1.0;
            } else {
                material.uniforms.u_layers.value = config.layers;
                material.uniforms.u_use_manual.value = 0.0;
            }

            material.uniforms.u_brightness.value = config.brightness;
            material.uniforms.u_show_core.value = config.showCore;
            material.uniforms.u_model.value = config.model;

            renderer.render(scene, camera);
        }

        // --- UI Logic ---
        // Handles UI toggling, slider updates, and texture regeneration.

        const uiLayer = document.getElementById('ui-layer');
        const toggleBtn = document.getElementById('toggle-btn');
        let isMin = false;

        toggleBtn.addEventListener('click', () => {
            isMin = !isMin;
            if (isMin) {
                uiLayer.classList.add('minimized');
                toggleBtn.innerText = '+';
            } else {
                uiLayer.classList.remove('minimized');
                toggleBtn.innerText = '–';
            }
        });

        const massSlider = document.getElementById('mass-slider');
        const spreadSlider = document.getElementById('spread-slider');
        const layersSlider = document.getElementById('layers-slider');
        const brightSlider = document.getElementById('bright-slider');
        const densitySlider = document.getElementById('density-slider');
        const coreCheck = document.getElementById('core-check');

        const massLabel = document.getElementById('mass-label');
        const spreadLabel = document.getElementById('spread-label');
        const coreLabel = document.getElementById('core-label');
        const btnVoid = document.getElementById('btn-model-void');

        massSlider.addEventListener('input', (e) => {
            config.mass = e.target.value / 100;
            document.getElementById('mass-val').innerText = e.target.value + '%';
        });
        spreadSlider.addEventListener('input', (e) => {
            config.spread = e.target.value / 100;
            document.getElementById('spread-val').innerText = (e.target.value/100).toFixed(2) + 'x';
        });
        layersSlider.addEventListener('input', (e) => {
            config.layers = parseFloat(e.target.value);
            document.getElementById('layers-val').innerText = e.target.value;
        });
        brightSlider.addEventListener('input', (e) => {
            config.brightness = e.target.value / 100;
            document.getElementById('bright-val').innerText = e.target.value + '%';
        });
        densitySlider.addEventListener('input', (e) => {
            document.getElementById('density-val').innerText = e.target.value + '%';
        });

        // When density changes, we must regenerate the textures.
        densitySlider.addEventListener('change', (e) => {
            config.density = e.target.value / 100;

            const newCluster = createClusterTexture(config.density);
            newCluster.wrapS = THREE.ClampToEdgeWrapping;
            newCluster.wrapT = THREE.ClampToEdgeWrapping;
            material.uniforms.u_cluster.value = newCluster;

            const newFg = createForegroundTexture(config.density);
            newFg.wrapS = THREE.RepeatWrapping;
            newFg.wrapT = THREE.RepeatWrapping;
            material.uniforms.u_fg.value = newFg;

            if (currentMode === 'galaxies') {
                const newBg = createBackgroundTexture(config.density);
                newBg.wrapS = THREE.RepeatWrapping;
                newBg.wrapT = THREE.RepeatWrapping;
                material.uniforms.u_bg.value = newBg;
            } else if (currentMode === 'dotted-grid') {
                const newBg = createDottedGridTexture(config.density);
                newBg.wrapS = THREE.RepeatWrapping;
                newBg.wrapT = THREE.RepeatWrapping;
                material.uniforms.u_bg.value = newBg;
            }
        });

        coreCheck.addEventListener('change', (e) => {
            config.showCore = e.target.checked ? 1.0 : 0.0;
        });

        const modelBtns = document.querySelectorAll('.model-btn');
        const btnPoint = document.getElementById('btn-model-point');
        const btnNFW = document.getElementById('btn-model-nfw');

        function setModel(modelIndex) {
            config.model = modelIndex;
            modelBtns.forEach(b => b.classList.remove('active'));

            if (modelIndex === 0) btnPoint.classList.add('active');
            else if (modelIndex === 1) btnNFW.classList.add('active');
            else if (modelIndex === 2) btnVoid.classList.add('active');

            // Update UI Labels and Defaults based on Model
            if (modelIndex === 2) { // Voids
                massLabel.firstChild.textContent = "Void Inner Density (% Mean)";
                spreadLabel.firstChild.textContent = "Void Radius";
                coreLabel.childNodes[0].textContent = "Show Void Boundary & Center ";

                // Set Defaults for Voids
                config.mass = 0.40;
                massSlider.value = 40;
                document.getElementById('mass-val').innerText = "40%";

                config.spread = 1.0;
                spreadSlider.value = 100;
                document.getElementById('spread-val').innerText = "1.00x";

                coreCheck.checked = true;
                config.showCore = 1.0;
            } else {
                massLabel.firstChild.textContent = "Cluster Mass";
                spreadLabel.firstChild.textContent = "Cluster Spread";
                coreLabel.childNodes[0].textContent = "Show Dark Matter Halo ";

                // Restore defaults if moving away (optional, or keep values)
                // Assuming restore to standard defaults if we just switched
                if (massSlider.value == 40 && spreadSlider.value == 100) {
                     config.mass = 1.0;
                     massSlider.value = 100;
                     document.getElementById('mass-val').innerText = "100%";
                }
            }
        }

        modelBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                setModel(parseFloat(btn.dataset.model));
            });
        });

        const presetBtns = document.querySelectorAll('.preset-btn');
        const layerList = document.getElementById('layer-list');
        const bgUploadInput = document.getElementById('bg-upload');
        const uploadLabel = document.getElementById('upload-label');
        const densityLabelText = document.getElementById('density-label-text');

        function updateTexture(type) {
            let newTex;

            if (type !== 'upload') {
                clearManualLayers();
            }

            material.uniforms.u_grid_mode.value = 0.0;

            if (type === 'galaxies') {
                newTex = createBackgroundTexture(config.density);
            } else if (type === 'bw-grid') {
                newTex = createBWGridTexture();
            } else if (type === 'color-grid') {
                newTex = createColorGridTexture();
                material.uniforms.u_grid_mode.value = 1.0;
            } else if (type === 'dotted-grid') {
                newTex = createDottedGridTexture(config.density);
            }

            if (newTex) {
                newTex.wrapS = THREE.RepeatWrapping;
                newTex.wrapT = THREE.RepeatWrapping;
                material.uniforms.u_bg.value = newTex;
            }
        }

        const btnGalaxies = document.getElementById('btn-galaxies');
        const btnBW = document.getElementById('btn-bw');
        const btnCol = document.getElementById('btn-col');
        const btnDotted = document.getElementById('btn-dotted');

        function setBgMode(mode) {
            currentMode = mode;
            presetBtns.forEach(b => b.classList.remove('active'));
            if(mode === 'galaxies') btnGalaxies.classList.add('active');
            else if(mode === 'bw-grid') btnBW.classList.add('active');
            else if(mode === 'color-grid') btnCol.classList.add('active');
            else if(mode === 'dotted-grid') btnDotted.classList.add('active');

            updateTexture(mode);

            if (mode === 'galaxies') {
                densitySlider.disabled = false;
                if(densityLabelText) densityLabelText.innerText = "Galaxy Density";

                // Reset to default 3 layers for Galaxies
                config.layers = 3;
                layersSlider.value = 3;
                document.getElementById('layers-val').innerText = '3';

            } else {
                // For all grids, default to 1 layer
                config.layers = 1;
                layersSlider.value = 1;
                document.getElementById('layers-val').innerText = '1';

                if (mode === 'dotted-grid') {
                    densitySlider.disabled = false;
                    if(densityLabelText) densityLabelText.innerText = "Grid Point Density";
                } else {
                    densitySlider.disabled = true;
                    if(densityLabelText) densityLabelText.innerText = "Galaxy Density";
                }
            }
        }

        presetBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                setBgMode(btn.dataset.type);
            });
        });

        // Manages the UI list for manually uploaded background layers
        function updateLayerUI() {
            layerList.innerHTML = '';
            manualLayers.forEach((layer, index) => {
                const item = document.createElement('div');
                item.className = 'layer-item';

                const name = document.createElement('span');
                name.className = 'layer-name';
                name.innerText = `Layer ${index + 1}: ${layer.name}`;

                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-layer-btn';
                removeBtn.innerText = '×';
                removeBtn.onclick = () => removeLayer(index);

                item.appendChild(name);
                item.appendChild(removeBtn);
                layerList.appendChild(item);
            });

            if (manualLayers.length > 0) {
                densitySlider.disabled = true;
            } else {
                if (currentMode === 'galaxies' || currentMode === 'dotted-grid') {
                    densitySlider.disabled = false;
                }
            }

            if (manualLayers.length === 0) {
                uploadLabel.innerText = "Add Own Background Image";
                uploadLabel.style.display = 'block';
            } else if (manualLayers.length < 8) {
                uploadLabel.innerText = `Add Background Layer ${manualLayers.length + 1}`;
                uploadLabel.style.display = 'block';
            } else {
                uploadLabel.style.display = 'none';
            }

            // Lock layer count slider if using manual layers
            if (manualLayers.length > 1) {
                layersSlider.disabled = true;
                // Show fixed count
                layersSlider.value = manualLayers.length;
                document.getElementById('layers-val').innerText = manualLayers.length;
            } else {
                layersSlider.disabled = false;
                // Restore config value
                layersSlider.value = config.layers;
                document.getElementById('layers-val').innerText = config.layers;
            }

            for(let i=0; i<8; i++) {
                material.uniforms[`u_manual_tex_${i}`].value = null;
            }

            if (manualLayers.length > 0) {
                presetBtns.forEach(b => b.classList.remove('active'));
                currentMode = 'upload';

                manualLayers.forEach((layer, i) => {
                    material.uniforms[`u_manual_tex_${i}`].value = layer.texture;
                });

                if (manualLayers.length === 1) {
                    material.uniforms.u_bg.value = manualLayers[0].texture;
                }
            }
        }

        function removeLayer(index) {
            manualLayers.splice(index, 1);
            if (manualLayers.length === 0) {
                setBgMode('galaxies');
            } else {
                updateLayerUI();
            }
        }

        function clearManualLayers() {
            if (manualLayers.length === 0) return;
            manualLayers = [];
            updateLayerUI();
        }

        bgUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const tex = new THREE.Texture(img);
                    tex.needsUpdate = true;
                    tex.wrapS = THREE.RepeatWrapping;
                    tex.wrapT = THREE.RepeatWrapping;

                    // If it's the first image, default to 1 layer
                    if (manualLayers.length === 0) {
                        config.layers = 1;
                    }

                    manualLayers.push({ texture: tex, name: file.name });
                    updateLayerUI();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            bgUploadInput.value = '';
        });

        // --- CREDIT RANDOMIZATION ---
        function randomizeCredits() {
            const names = ["Nico Schuster", "Andres Salcedo"];
            if (Math.random() > 0.5) {
                names.reverse();
            }
            document.getElementById('credit-text').innerText = `Concept & Visualization by ${names[0]} and ${names[1]}`;
        }

        // --- RESET FUNCTIONALITY ---
        // Reshuffles the seed to generate a new unique universe configuration
        document.getElementById('reshuffle-btn').addEventListener('click', () => {
            randomizeCredits();
            masterSeed = Math.floor(Math.random() * 100000);

            const newCluster = createClusterTexture(config.density);
            newCluster.wrapS = THREE.ClampToEdgeWrapping;
            newCluster.wrapT = THREE.ClampToEdgeWrapping;
            material.uniforms.u_cluster.value = newCluster;

            const newFg = createForegroundTexture(config.density);
            newFg.wrapS = THREE.RepeatWrapping;
            newFg.wrapT = THREE.RepeatWrapping;
            material.uniforms.u_fg.value = newFg;

            if (currentMode === 'galaxies') {
                const newBg = createBackgroundTexture(config.density);
                newBg.wrapS = THREE.RepeatWrapping;
                newBg.wrapT = THREE.RepeatWrapping;
                material.uniforms.u_bg.value = newBg;
            } else if (currentMode === 'dotted-grid') {
                const newBg = createDottedGridTexture(config.density);
                newBg.wrapS = THREE.RepeatWrapping;
                newBg.wrapT = THREE.RepeatWrapping;
                material.uniforms.u_bg.value = newBg;
            }
        });

        // Resets everything to default values
        document.getElementById('reset-main').addEventListener('click', () => {
            randomizeCredits();
            config = { ...defaultConfig };

            massSlider.value = 100;
            document.getElementById('mass-val').innerText = '100%';

            spreadSlider.value = 100;
            document.getElementById('spread-val').innerText = '1.00x';

            layersSlider.value = 3;
            document.getElementById('layers-val').innerText = '3';

            densitySlider.value = 100;
            document.getElementById('density-val').innerText = '100%';

            brightSlider.value = 100;
            document.getElementById('bright-val').innerText = '100%';

            coreCheck.checked = true;

            setModel(0);
            manualLayers = [];
            updateLayerUI();
            setBgMode('galaxies');

            masterSeed = Math.floor(Math.random() * 100000);

            const newCluster = createClusterTexture(config.density);
            newCluster.wrapS = THREE.ClampToEdgeWrapping;
            newCluster.wrapT = THREE.ClampToEdgeWrapping;
            material.uniforms.u_cluster.value = newCluster;

            const newFg = createForegroundTexture(config.density);
            newFg.wrapS = THREE.RepeatWrapping;
            newFg.wrapT = THREE.RepeatWrapping;
            material.uniforms.u_fg.value = newFg;
        });

        // --- SNAPSHOT FUNCTIONALITY WITH URL CREDIT & BACKGROUND ---
        document.getElementById('snapshot-btn').addEventListener('click', () => {
            // 1. Render the 3D scene fresh
            renderer.render(scene, camera);

            // 2. Create a temporary 2D canvas
            const virtualCanvas = document.createElement('canvas');
            virtualCanvas.width = renderer.domElement.width;
            virtualCanvas.height = renderer.domElement.height;
            const ctx = virtualCanvas.getContext('2d');

            // 3. Draw the WebGL rendered image
            ctx.drawImage(renderer.domElement, 0, 0);

            // 4. Configure Text
            const text = "nicosmo.github.io/lensing_visualization/";
            const fontSize = Math.max(12, Math.floor(virtualCanvas.width * 0.015));
            ctx.font = `300 ${fontSize}px Inter, sans-serif`;
            ctx.textAlign = "right";
            ctx.textBaseline = "bottom";

            // 5. Calculate positions & Measure text for the background box
            const marginX = virtualCanvas.width * 0.02; // 2% margin
            const x = virtualCanvas.width - marginX;
            const y = virtualCanvas.height - 15;

            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;
            const padding = fontSize * 0.5; // Padding relative to font size
            const boxHeight = fontSize + padding;

            // 6. Draw the Dark Background Box
            ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; // 60% opacity black
            // Because align is 'right', we calculate the box start position to the left of x
            ctx.fillRect(
                x - textWidth - padding,     // X: Start to the left of text
                y - fontSize - (padding/2),  // Y: Start above the text
                textWidth + (padding * 2),   // Width: Text width + padding on both sides
                boxHeight                    // Height
            );

            // 7. Draw the Text on top
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)"; // 90% opacity white
            ctx.fillText(text, x, y);

            // 8. Save
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `gravitational_lens_${timestamp}.png`;
            link.href = virtualCanvas.toDataURL('image/png');

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        init();
    </script>
</body>

</html>


